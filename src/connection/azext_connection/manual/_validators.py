# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
import argparse
from random import randint
import re
from typing import ForwardRef
from knack.prompting import prompt, prompt_y_n, prompt_pass
from azure.cli.core.commands.client_factory import get_subscription_id
from azure.cli.core.azclierror import (
    RequiredArgumentMissingError,
    InvalidArgumentValueError
)
from ._resource_config import (
    SOURCE_RESOURCES,
    TARGET_RESOURCES,
    SOURCE_RESOURCES_PARAMS,
    TARGET_RESOURCES_PARAMS,
    DEFAULT_AUTH_TYPE
)


def get_source_resource_name(cmd):
    # get source resource name
    # e.g, az webapp connection list: => RESOURCE.WebApp
    source = None
    for item in SOURCE_RESOURCES:
        if item.value in cmd.name:
            source = item
    return source


def get_target_resource_name(cmd):
    # get target resource name
    # e.g, az webapp connection create postgres: => RESOURCE.Postgres
    target = None
    for item in TARGET_RESOURCES:
        if item.value in cmd.name:
            target = item
    return target


def get_required_args(cmd):
    # get required arguments for a command
    source = get_source_resource_name(cmd)
    target = get_target_resource_name(cmd)

    arg_help, arg_option = dict(), dict()
    
    if not (cmd.name.endswith('list') or 'create' in cmd.name):
        arg_help = {'connection_name': 'The connection name'}
        arg_option = {'connection_name': '--connection-name'}

    for arg, content in SOURCE_RESOURCES_PARAMS.get(source).items():
        arg_help[arg] = content.get('help')
        arg_option[arg] = content.get('options')[0]
    
    for arg, content in TARGET_RESOURCES_PARAMS.get(target, {}).items():
        arg_help[arg] = content.get('help')
        arg_option[arg] = content.get('options')[0]
    
    for arg, content in DEFAULT_AUTH_TYPE.get(source, {}).get(target, {}).items():
        arg_help[arg] = content.get('help')
        arg_option[arg] = content.get('options')[0]
    
    return arg_help, arg_option
        

def get_resource_regex(resource):
    # replace '{...}' with '[^/]*' for regex matching
    regex = resource
    for item in re.findall('(\{[^\{\}]*\})', resource):
        regex = regex.replace(item, '[^/]*')
    return regex


def generate_connection_name(cmd, namespace):
    # generate connection name for users if not provided
    import random
    source = get_source_resource_name(cmd)
    target = get_target_resource_name(cmd)
    return '{}_{}_{}'.format(source.value, target.value, str(randint(10000, 99999)))


def check_required_args(resource, cmd_arg_values):
    # check whether a resource's required arguments are in cmd_arg_values
    args = re.findall('\{([^\{\}]*)\}', resource)
    args.remove('subscription')
    for arg in args:
        if not cmd_arg_values.get(arg, None):
            return False
    return True


def validate_source_resource(cmd, namespace):
    source = get_source_resource_name(cmd)
    if getattr(namespace, 'source_id', None):
        matched = False
        for resource in SOURCE_RESOURCES.values():
            matched = re.match(get_resource_regex(resource), namespace.source_id)
            if matched:
                namespace.source_id = matched.group()
                return True
        if not matched:
            raise InvalidArgumentValueError('Source resource id is invalid. {}'.format(namespace.source_id))
    elif getattr(namespace, 'id', None):
        matched = False
        for resource in SOURCE_RESOURCES.values():
            regex = '({})/providers/Microsoft.ServiceLinker/linkers/([^/]*)'.format(get_resource_regex(resource))
            matched = re.match(regex, namespace.id)
            if matched:
                namespace.source_id = matched.group(1)
                namespace.connection_name = matched.group(2)
                return True
        if not matched:
            raise InvalidArgumentValueError('Connection id is invalid. {}'.format(namespace.id))
    
    return False


def validate_target_resource(cmd, namespace):
    if namespace.target_id:
        matched = False
        for resource in TARGET_RESOURCES.values():
            matched = re.match(get_resource_regex(resource), namespace.target_id)
            if matched:
                namespace.target_id = matched.group()
                return True
        if not matched:
            raise InvalidArgumentValueError('Target resource id is invalid. {}'.format(namespace.target_id))
    
    return False


def interactive_input(arg, hint):
    value = None
    if arg == 'secret_auth_info':
        name = prompt('User name of database: ')
        secret = prompt_pass('Password of database: ')
        value = {'name': name, 'secret': secret, 'auth_type': 'secret'}
    elif arg == 'user_identity_auth_info':
        id = prompt('Id: ')
        value = {'id': id, 'auth_type': 'userAssignedIdentity'}
    elif arg == 'service_principal_auth_info':
        id = prompt('Id: ')
        value = {'id': id, 'auth_type': 'servicePrincipal'}
    elif arg == 'system_identity_auth_info':
        value = {'auth_type': 'systemAssignedIdentity'}
    else:
        value = prompt('{}: '.format(hint))
    return value


def intelligent_experience(cmd, namespace, arg_help, arg_option):
    from colorama import Fore, Style
    
    # arguments found in command line
    cmd_arg_values = dict()
    for arg in arg_option:
        if getattr(namespace, arg, None):
            cmd_arg_values[arg] = getattr(namespace, arg, None)

    if cmd.cli_ctx.local_context.is_on:
        # arguments found in local context
        context_arg_values = dict()
        for arg in arg_option:
            if arg not in cmd_arg_values:
                if cmd.cli_ctx.local_context.get('connection', arg):
                    context_arg_values[arg] = cmd.cli_ctx.local_context.get('connection', arg)
        
        # apply local context arguments
        param_str = ''
        for arg in context_arg_values:
            option = arg_option[arg]
            value = context_arg_values[arg]
            param_str += '{} {}, '.format(option, value)
        if param_str:
            print(Fore.GREEN + 'Apply local context arguments: {}'.format(param_str.strip(', ')) + Style.RESET_ALL)
            cmd_arg_values.update(context_arg_values)

    # arguments from interactive inputs
    for arg in arg_option:
        if arg not in cmd_arg_values:
            help = arg_help[arg]
            value = interactive_input(arg, help)
            cmd_arg_values[arg] = value
    
    return cmd_arg_values
    

def validate_full_params(cmd, namespace):

    source  = get_source_resource_name(cmd)
    target = get_target_resource_name(cmd)
    cmd_arg_values = dict()

    if not validate_source_resource(cmd, namespace):
        arg_help, arg_option = get_required_args(cmd)
        cmd_arg_values = intelligent_experience(cmd, namespace, arg_help, arg_option)

        resource = SOURCE_RESOURCES.get(source)
        namespace.source_id = resource.format(
            subscription=get_subscription_id(cmd.cli_ctx),
            **cmd_arg_values
        ) if check_required_args(resource, cmd_arg_values) else None

        if not (cmd.name.endswith('list') or 'create' in cmd.name):
            namespace.connection_name = cmd_arg_values.get('connection_name')

    if 'create' in cmd.name.split(' '):
        resource = TARGET_RESOURCES.get(target)
        namespace.target_id = resource.format(
            subscription=get_subscription_id(cmd.cli_ctx),
            **cmd_arg_values
        ) if check_required_args(resource, cmd_arg_values) else None

        for auth_prop in DEFAULT_AUTH_TYPE.get(source, {}).get(target, {}).keys():
            setattr(namespace, auth_prop, cmd_arg_values.get(auth_prop))

        if not namespace.connection_name:
            namespace.connection_name = generate_connection_name(cmd, namespace)